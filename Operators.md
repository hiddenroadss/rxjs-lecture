# Operators

RxJS в основному корисний для своїх операторів, навіть якщо Observable є основою. 
Оператори є основними елементами, які дозволяють легко складати складний асинхронний код декларативним способом.

## Що таке оператори?

Оператори є функціями. Існує два типи операторів:

Конвеєрні оператори – це тип, який можна передати в Observables за допомогою синтаксису observableInstance.pipe(operator()). 
До них належать filter(...) і mergeMap(...). При виклику вони не змінюють існуючий екземпляр Observable. 
Замість цього вони повертають новий Observable, логіка підписки якого базується на першому Observable.

> Оператор Pipeable — це функція, яка приймає Observable як вхідні дані та повертає іншу Observable. Це чиста операція: попередній Observable залишається незмінним.

Оператор Pipeable є по суті чистою функцією, яка приймає один Observable як вхідні дані та генерує інший Observable як вихідні дані. Підписка на вихідний Observable також підписується на вхідний Observable.

Оператори створення — це інший вид операторів, які можна викликати як окремі функції для створення нового Observable. Наприклад: of(1, 2, 3) створює спостережуваний, який буде випромінювати 1, 2 і 3 один за одним. Оператори створення будуть розглянуті більш детально в наступному розділі.

Наприклад, оператор під назвою map є аналогом однойменного методу Array. Подібно до того, як [1, 2, 3].map(x => x * x) дасть [1, 4, 9], Observable створюється так:
```javascript
import { of, map } from 'rxjs';

of(1, 2, 3)
  .pipe(map((x) => x * x))
  .subscribe((v) => console.log(`value: ${v}`));

// Logs:
// value: 1
// value: 4
// value: 9
```
видасть 1, 4, 9. Іншим корисним оператором є first:
```javascript
import { of, first } from 'rxjs';

of(1, 2, 3)
  .pipe(first())
  .subscribe((v) => console.log(`value: ${v}`));

// Logs:
// value: 1
```
Зауважте, що карту логічно потрібно створювати на льоту, оскільки їй потрібно надати функцію відображення. 
На відміну від цього, first може бути константою, але все одно створюється на льоту. 
Як правило, усі оператори створюються незалежно від того, чи потрібні їм аргументи чи ні.

## Piping

Конвеєрні оператори є функціями, тому їх можна використовувати як звичайні функції: op()(obs) — але на практиці, як правило,
багато з них згортаються разом і швидко стають нечитабельними: op4()(op3()(op2( )(op1()(obs)))). 
З цієї причини у Observables є метод під назвою .pipe(), який виконує те саме, але його набагато легше читати:
```javascript
obs.pipe(op1(), op2(), op3(), op4());
```
З точки зору стилістики, op()(obs) ніколи не використовується, навіть якщо є лише один оператор; obs.pipe(op()) є загальноприйнятим.

## Creating Operators

Що таке оператори створення? На відміну від конвеєрних операторів, оператори створення — це функції, які можна використовувати для створення Observable із певною загальною попередньо визначеною поведінкою або шляхом приєднання до інших Observable.

Типовим прикладом оператора створення може бути інтервальна функція. Він приймає число (не Observable) як вхідний аргумент і створює Observable як вихід:
```javascript
import { interval } from 'rxjs';

const observable = interval(1000 /* number of milliseconds */);
```
51 / 5,000
Translation results
Перегляньте список усіх статичних операторів створення тут.

## Higher-order observables

Observables найчастіше випромінюють звичайні значення, такі як рядки та числа, але напрочуд часто необхідно обробляти Observables Observables, 
так звані Observables вищого порядку. 
Наприклад, уявіть, що у вас є Observable, що видає рядки, які є URL-адресами файлів, які ви хочете переглянути. Код може виглядати так:
```javascript
const fileObservable = urlObservable.pipe(map((url) => http.get(url)));
```
http.get() повертає Observable (імовірно рядок або масиви рядків) для кожної окремої URL-адреси. Тепер у вас є Observable з Observable, Observable вищого порядку.

Але як працювати з Observable вищого порядку? Як правило, шляхом зведення: (якимось чином) перетворюючи Observable вищого порядку на звичайний Observable. Наприклад:
```javascript
const fileObservable = urlObservable.pipe(
  map((url) => http.get(url)),
  concatAll()
);
```
Оператор concatAll() підписується на кожен «внутрішній» Observable, який виходить із «зовнішнього» Observable, 
і копіює всі випущені значення, доки цей Observable не завершиться, і не переходить до наступного. 
Усі значення об’єднані таким чином. Інші корисні оператори зведення (які називаються операторами з’єднання).
- mergeAll() — підписується на кожен внутрішній Observable, щойно він надходить, а потім видає кожне значення, коли воно надходить
- switchAll() — підписується на перший внутрішній Observable, коли він надходить, і видає кожне значення, коли воно надходить, але коли наступний внутрішній Observable надходить, скасовує підписку на попередній і підписується на новий.
- exhaustAll() — підписується на перший внутрішній Observable, коли він надходить, і видає кожне значення, коли воно надходить, відкидаючи всі нові внутрішні Observable, доки перший не завершиться, а потім чекає на наступний внутрішній Observable.

Подібно до того, як багато бібліотек масивів поєднують map() і flat() (або flatten()) в один flatMap(), існують еквіваленти відображення всіх операторів зведення RxJS concatMap(), mergeMap(), switchMap() і exhaustMap ().

## Marble diagrams

Щоб пояснити, як працюють оператори, текстових описів часто недостатньо. 
Багато операторів пов’язані з часом, вони можуть, наприклад, затримувати, відбирати, дроселювати або зменшувати значення викидів різними способами.
Діаграми часто є кращим інструментом для цього. 
Мармурові діаграми — це візуальне представлення того, як працюють оператори, і включають вхідні Observable(и), оператор і його параметри, а також вихідні Observable.

> На мармуровій діаграмі час тече праворуч, і діаграма описує, як значення («кульки») випускаються під час виконання Observable.

Нижче ви можете побачити анатомію мармурової діаграми.
![image](https://user-images.githubusercontent.com/64136789/185767990-556eb075-31f2-4a78-ab26-67a16dd555a4.png)

На цьому сайті документації ми широко використовуємо мармурові діаграми, щоб пояснити, як працюють оператори. Вони також можуть бути корисними в інших контекстах, наприклад,
на дошці або навіть у наших модульних тестах (як діаграми ASCII).

