# Оператори

RxJS в основному корисний своїми операторами, навіть якщо Об'єкт Спостереження є основою. 

Оператори є основними елементами, які дозволяють легко складати складний асинхронний код декларативним способом.

## Що таке оператори?

Оператори - це функції. Їх існує два типи:

Pipable operators – це тип, який можна передати в Об'єкт Спостереження за допомогою синтаксису `observableInstance.pipe(operator())`. 
До них належать `filter(...)` і `mergeMap(...)`. При виклику вони не змінюють існуючий екземпляр Об'єкту Спостреження. 
Замість цього вони повертають новий Об'єкт Спостереження, логіка підписки якого базується на першому.

> Pipeable оператор — це функція, яка приймає Об'єкт Спостереження як вхідні дані та повертає інший Об'єкт Спостереження. Це чиста операція: вхідний Об'єкт Спостереження залишається незмінним.

Pipeable оператор є по суті чистою функцією, яка приймає один Об'єкт Спостереження як вхідні дані та генерує інший Об'єкт Спостереження як вихідні дані. Підписка на вихідний Об'єкт Спостереження також підписується на вхідний Об'єкт Спостереження.

**Оператори створення** — це інший вид операторів, які можна викликати як окремі функції для створення нового Об'єкту Спостереження. Наприклад: `of(1, 2, 3)` створює Об'єкт Спостереження, який буде віддавати 1, 2 і 3 один за одним. Оператори створення будуть розглянуті більш детально в наступному розділі.

Наприклад, оператор під назвою `map` є аналогом однойменного методу `Array`. Подібно до того, як `[1, 2, 3].map(x => x * x) дасть [1, 4, 9]`, Об'єкт Спостереження створюється так:
```javascript
import { of, map } from 'rxjs';

of(1, 2, 3)
  .pipe(map((x) => x * x))
  .subscribe((v) => console.log(`value: ${v}`));

// Logs:
// value: 1
// value: 4
// value: 9
```
видасть 1, 4, 9. Іншим корисним оператором є `first`:
```javascript
import { of, first } from 'rxjs';

of(1, 2, 3)
  .pipe(first())
  .subscribe((v) => console.log(`value: ${v}`));

// Logs:
// value: 1
```
Зауважте, що `map` потрібно створювати на льоту, оскільки їй потрібно надати функцію відображення. 
На відміну від цього, `first` може бути константою, але все одно створюється на льоту. 
Як правило, усі оператори створюються незалежно від того, чи потрібні їм аргументи чи ні.

## Piping

Pipable operators є функціями, тому їх можна використовувати як звичайні функції: `op()(obs)` — але на практиці, як правило,
багато з них згортаються разом і швидко стають нечитабельними: `op4()(op3()(op2( )(op1()(obs))))`. 
З цієї причини у Об'єктів Спостереження є метод під назвою `.pipe()`, який виконує те саме, але його набагато легше читати:
```javascript
obs.pipe(op1(), op2(), op3(), op4());
```
З точки зору стилістики, `op()(obs)` ніколи не використовується, навіть якщо є лише один оператор; `obs.pipe(op())` є загальноприйнятим.

## Оператори Створення

Що таке оператори створення? На відміну від Pipable Operators, оператори створення — це функції, які можна використовувати для створення Об'єктів Спостереження із певною загальною попередньо визначеною поведінкою або шляхом приєднання до інших Об'єктів Спостереження.

Типовим прикладом оператора створення може бути інтервальна функція. Він приймає число (не Об'єкт Спостереження) як вхідний аргумент і створює Об'єкт Спостереження на виході:
```javascript
import { interval } from 'rxjs';

const observable = interval(1000 /* number of milliseconds */);
```

Перегляньте список усіх статичних операторів створення тут.

## Об'єкти Спостереження вищого порядку

Об'єкти Спостереження найчастіше віддають прості значення, такі як рядки та числа, але напрочуд часто необхідно обробляти так звані Об'єкти Спостереження вищого порядку. 
Наприклад, уявіть, що у вас є Об'єкт Спостереження, що видає рядки, які є URL-адресами файлів, які ви хочете переглянути. Код може виглядати так:
```javascript
const fileObservable = urlObservable.pipe(map((url) => http.get(url)));
```
`http.get()` повертає Об'єкт Спостереження (імовірно рядок або масиви рядків) для кожної окремої URL-адреси. Тепер у вас є Об'єкт Спостереження всередині Об'єкту Спостереження, або **Об'єкт Спостереження вищого порядку**.

Але як працювати з Об'єктом Спостереження вищого порядку? Як правило, шляхом розрівнювання: (якимось чином) перетворюючи Об'єкт Спостереження вищого порядку на звичайний Об'єкт Спостереження. Наприклад:
```javascript
const fileObservable = urlObservable.pipe(
  map((url) => http.get(url)),
  concatAll()
);
```
Оператор `concatAll()` підписується на кожен «внутрішній» Об'єкт Спостереження, який виходить із «зовнішнього» Об'єкту Спостереження, 
і копіює всі випущені значення, доки цей Об'єкт Спостереження не завершиться, і не переходить до наступного. 
Усі значення об’єднані таким чином. Інші корисні оператори зведення (які називаються операторами з’єднання).
- `mergeAll()` — підписується на кожен внутрішній Об'єкт Спостереження, щойно він надходить, а потім видає кожне значення, коли воно надходить
- `switchAll()` — підписується на перший внутрішній Об'єкт Спостереження, коли він надходить, і видає кожне значення, коли воно надходить, але коли наступний внутрішній Об'єкт Спостереження надходить, скасовує підписку на попередній і підписується на новий.
- `exhaustAll()` — підписується на перший внутрішній Об'єкт Спостереження, коли він надходить, і видає кожне значення, коли воно надходить, відкидаючи всі нові внутрішні Об'єкти Спостереження, доки перший не завершиться, а потім чекає на наступний внутрішній Об'єкт Спостереження.

Подібно до того, як багато бібліотек поєднують `map()` і `flat()` (або `flatten()`) в один `flatMap()`, існують еквіваленти відображення всіх операторів розрівнювання RxJS `concatMap()`, `mergeMap()`, `switchMap()` і `exhaustMap()`.

## Кулькові діаграми

Щоб пояснити, як працюють оператори, текстових описів часто недостатньо. 
Багато операторів пов’язані з часом, вони можуть, наприклад, затримувати, відбирати, дроселювати або зменшувати викидання значень різними способами.

Діаграми часто є кращим інструментом для цього. 
Кулькові діаграми — це візуальне представлення того, як працюють оператори, і включають вхідні Об'єкт(и) Спостереження, оператор і його параметри, а також вихідний Об'єкт Спостереження.

> На кулькових діаграмах час тече зліва направо, і діаграма описує, як значення («кульки») випускаються під час виконання Об'єкту Спостереження.

Нижче ви можете побачити анатомію кулькової діаграми.
![image](https://user-images.githubusercontent.com/64136789/185767990-556eb075-31f2-4a78-ab26-67a16dd555a4.png)

На цьому сайті документації ми широко використовуємо кулькові діаграми, щоб пояснити, як працюють оператори. Вони також можуть бути корисними в інших контекстах, наприклад,
на дошці або навіть у наших модульних тестах (як діаграми ASCII).

