# Оператори

RxJS в основному корисний своїми операторами, навіть якщо Об'єкт Спостереження є основою.

Оператори є основними елементами, які дозволяють легко складати складний асинхронний код декларативним способом.

## Що таке оператори?

Оператори - це функції. Їх існує два типи:

Pipable operators – це тип, який можна передати в Об'єкт Спостереження за допомогою синтаксису `observableInstance.pipe(operator())`.
При виклику вони не змінюють існуючий екземпляр Об'єкту Спостреження.
Замість цього вони повертають новий Об'єкт Спостереження, логіка підписки якого базується на першому.

> Pipeable оператор — це функція, яка приймає Об'єкт Спостереження як вхідні дані та повертає інший Об'єкт Спостереження. Це чиста операція: вхідний Об'єкт Спостереження залишається незмінним.

Pipeable оператор є по суті чистою функцією, яка приймає один Об'єкт Спостереження як вхідні дані та генерує інший Об'єкт Спостереження як вихідні дані. Підписка на вихідний Об'єкт Спостереження також підписується на вхідний Об'єкт Спостереження.

**Оператори створення** — це інший вид операторів, які можна викликати як окремі функції для створення нового Об'єкту Спостереження. Наприклад: `of(1, 2, 3)` створює Об'єкт Спостереження, який буде віддавати 1, 2 і 3 один за одним. Оператори створення будуть розглянуті більш детально в наступному розділі.

Наприклад, оператор під назвою `map` є аналогом однойменного методу `Array`. Подібно до того, як `[1, 2, 3].map(x => x * x) дасть [1, 4, 9]`, Об'єкт Спостереження створюється так:

```javascript
import { of, map } from "rxjs";

of(1, 2, 3)
    .pipe(map((x) => x * x))
    .subscribe((v) => console.log(`value: ${v}`));

// Logs:
// value: 1
// value: 4
// value: 9
```

видасть 1, 4, 9. Іншим корисним оператором є `first`:

```javascript
import { of, first } from "rxjs";

of(1, 2, 3)
    .pipe(first())
    .subscribe((v) => console.log(`value: ${v}`));

// Logs:
// value: 1
```

Зауважте, що `map` потрібно створювати на льоту, оскільки їй потрібно надати функцію відображення.
На відміну від цього, `first` може бути константою, але все одно створюється на льоту.
Як правило, усі оператори створюються незалежно від того, чи потрібні їм аргументи чи ні.

## Piping

Pipable operators є функціями, тому їх можна використовувати як звичайні функції: `op()(obs)` — але на практиці, як правило,
багато з них згортаються разом і швидко стають нечитабельними: `op4()(op3()(op2( )(op1()(obs))))`.
З цієї причини у Об'єктів Спостереження є метод під назвою `.pipe()`, який виконує те саме, але його набагато легше читати:

```javascript
obs.pipe(op1(), op2(), op3(), op4());
```

З точки зору стилістики, `op()(obs)` ніколи не використовується, навіть якщо є лише один оператор; `obs.pipe(op())` є загальноприйнятим.

## Оператори Створення

Що таке оператори створення? На відміну від Pipable Operators, оператори створення — це функції, які можна використовувати для створення Об'єктів Спостереження із певною загальною попередньо визначеною поведінкою або шляхом приєднання до інших Об'єктів Спостереження.

Типовим прикладом оператора створення може бути інтервальна функція. Він приймає число (не Об'єкт Спостереження) як вхідний аргумент і створює Об'єкт Спостереження на виході:

```javascript
import { interval } from "rxjs";

const observable = interval(1000 /* number of milliseconds */);
```

Перегляньте список усіх статичних операторів створення тут.

## Об'єкти Спостереження вищого порядку

Об'єкти Спостереження найчастіше віддають прості значення, такі як рядки та числа, але напрочуд часто необхідно обробляти так звані Об'єкти Спостереження вищого порядку.
Наприклад, уявіть, що у вас є Об'єкт Спостереження, що видає рядки, які є URL-адресами файлів, які ви хочете переглянути. Код може виглядати так:

```javascript
const fileObservable = urlObservable.pipe(map((url) => http.get(url)));
```

`http.get()` повертає Об'єкт Спостереження (імовірно рядок або масиви рядків) для кожної окремої URL-адреси. Тепер у вас є Об'єкт Спостереження всередині Об'єкту Спостереження, або **Об'єкт Спостереження вищого порядку**.

Але як працювати з Об'єктом Спостереження вищого порядку? Як правило, шляхом розрівнювання: (якимось чином) перетворюючи Об'єкт Спостереження вищого порядку на звичайний Об'єкт Спостереження. Наприклад:

```javascript
const fileObservable = urlObservable.pipe(
    map((url) => http.get(url)),
    concatAll()
);
```

Оператор `concatAll()` підписується на кожен «внутрішній» Об'єкт Спостереження, який виходить із «зовнішнього» Об'єкту Спостереження,
і копіює всі випущені значення, доки цей Об'єкт Спостереження не завершиться, і не переходить до наступного.
Усі значення об’єднані таким чином. Інші корисні оператори зведення (які називаються операторами з’єднання).

-   `mergeAll()` — підписується на кожен внутрішній Об'єкт Спостереження, щойно він надходить, а потім видає кожне значення, коли воно надходить
-   `switchAll()` — підписується на перший внутрішній Об'єкт Спостереження, коли він надходить, і видає кожне значення, коли воно надходить, але коли наступний внутрішній Об'єкт Спостереження надходить, скасовує підписку на попередній і підписується на новий.
-   `exhaustAll()` — підписується на перший внутрішній Об'єкт Спостереження, коли він надходить, і видає кожне значення, коли воно надходить, відкидаючи всі нові внутрішні Об'єкти Спостереження, доки перший не завершиться, а потім чекає на наступний внутрішній Об'єкт Спостереження.

Подібно до того, як багато бібліотек поєднують `map()` і `flat()` (або `flatten()`) в один `flatMap()`, існують еквіваленти відображення всіх операторів розрівнювання RxJS `concatMap()`, `mergeMap()`, `switchMap()` і `exhaustMap()`.

## Кулькові діаграми

Щоб пояснити, як працюють оператори, текстових описів часто недостатньо.
Багато операторів пов’язані з часом, вони можуть, наприклад, затримувати, відбирати, дроселювати або зменшувати викидання значень різними способами.

Діаграми часто є кращим інструментом для цього.
Кулькові діаграми — це візуальне представлення того, як працюють оператори, і включають вхідні Об'єкт(и) Спостереження, оператор і його параметри, а також вихідний Об'єкт Спостереження.

> На кулькових діаграмах час тече зліва направо, і діаграма описує, як значення («кульки») випускаються під час виконання Об'єкту Спостереження.

Нижче ви можете побачити анатомію кулькової діаграми.
![image](https://user-images.githubusercontent.com/64136789/185767990-556eb075-31f2-4a78-ab26-67a16dd555a4.png)

На цьому сайті документації ми широко використовуємо кулькові діаграми, щоб пояснити, як працюють оператори. Вони також можуть бути корисними в інших контекстах, наприклад,
на дошці або навіть у наших модульних тестах (як діаграми ASCII).

### New

Об'єкти Спостереження є асинхронними операціями, тому нам потрібен спосіб представити плин часу. Це можна зробити за допомогою стрілки, що рухається зліва направо.

![image](https://miro.medium.com/max/600/1*aUjUVnDKc-JdNzD0y8IMWg.png)

Вертикальна лінія на кінці стрілки означає успішне завершення Об'єкта Спостереження. Але що, якщо у Об'єкта Спостереження є помилка?

![image](https://miro.medium.com/max/600/1*XopupLvHC-i6ntailoLEQw.png)

Якщо в Об'єкта Спостереження виникає помилка, вона позначається символом X. Після появи помилки Об'єкт Спостереження більше не видає жодних значень.

![image](https://miro.medium.com/max/600/1*ZvJ9aD8k3ywo4BTs28HLEA.png)

І, нарешті, ці кольорові кульки представляють значення та можуть з’являтися будь-де на часовій шкалі стрілки. Ці значення можуть бути рядками, числами, логічними значеннями або будь-яким іншим базовим типом.

![image](https://miro.medium.com/max/600/1*ZtA0Up-0zKXxcLwh7zc-cg.png)

Пам’ятайте, кулькові діаграми допомагають нам зрозуміти оператори. І оператори бувають двох форм:

1. Оператори створення (of, from, timer тощо)
2. Конвеєрні оператори (map, take, filter тощо)

Оператори створення є автономними (вони створюють власні значення), що означає, що їхні кулькові діаграми є лише однією стрілкою:

![image](https://miro.medium.com/max/700/1*a6BMBG_UFmZ-9iTVJDdX8A.png)

```javascript
import { interval, take } from "rxjs";

const numbers = interval(1000);

numbers.subscribe((x) => console.log("Next: ", x));

// Logs:
// Next: 0
// Next: 1
// Next: 2
// Next: 3
// Next...
```

І конвеєрним операторам потрібен «Input Observable» як джерело, оскільки вони самі не видають значень. Вони просто «оперують» цими значеннями. Таким чином, ви побачите кулькові діаграми для Pipable операторів з 1 або більше «Вхідними Об'єктами Спостереження», самим оператором і «Вихідним Об'єктом Спостереження».

Просто подумайте про це як про звичайні функції (технічно «чисті функції»), за винятком того, що їхні аргументи є Об'єктами Спостереження і значення, які вони повертають також є Об'єктами Спостереження.

Ось приклад:

![image](https://miro.medium.com/max/600/1*n7qbIBNC8jqpokRQ0BY-jg.png)

Важливо зауважити, що в деяких випадках порядок Об'єктів Спостереження має значення. Хоча деякі оператори повертають той самий вихідний Об'єкт Спостереження незалежно від порядку двох вхідних Об'єктів Спостереження, деякі оператори фактично використовують порядок цих вхідних даних для формування виводу.

Наведений вище оператор `concat()` є чудовим прикладом цього. Зверніть увагу, як вихідний Об'єкт Спостереження повертає три значення, випущені з вхідного Об'єкта Спостереження #1, перш ніж повернути два значення, випущені з вхідного Об'єкта Спостереження #2, навіть якщо обидва значення Об'єкта Спостереження #2 були випущені до останніх двох значень Об'єкта Спостереження #1.

У RxJS ми зазвичай називаємо вхідний Об'єкт Спостереження №1 «зовнішнім», а вхідний Об'єкт Спостереження №2 — «внутрішнім».

Як я вже сказав, порядок не завжди має значення. Візьмемо, наприклад, оператор `merge()`:

![image](https://miro.medium.com/max/700/1*kE77SCCW6HEdpMwvixthdQ.png)

Незалежно від того, в якому порядку викликаються два вхідних Об'єкти Спостереження, вихідний Об'єкт Спостереження завжди видаватиме однакові значення.

Щоб зрозуміти цю публікацію надалі, вам потрібно розібратися з певною термінологією:

**Зовнішній Об'єкт Спостереження**: або те, що я назвав «вхідний Об'єкт Спостереження №1», є Об'єктом Спостереження, який знаходиться у верхній частині кожної діаграми. Його називають «зовнішнім», тому що він зазвичай виглядає так під час написання коду:

```javascript
outerObservable().pipe(mergeMapTo(innerObservable(), (x, y) => x + y));
```

**Внутрішній Об'єкт Спостереження**: або те, що я назвав «вхідний Об'єкт Спостереження #2», є Об'єктом Спостереження нижче зовнішнього Об'єкта Спостереження, але перед оператором на кожній діаграмі. Його називають «внутрішнім» з тієї ж причини, що й вище.

**Вихідний Об'єкт Спостереження**: під час використання операторів RxJS іноді існує багато шарів між вхідними Об'єктом(ами) Спостереження і вихіднимм Об'єктами Спостереження, але ви можете думати про вихідний Об'єкт Спостереження як про «повернене значення».

**Вхідний Об'єкт Спостереження**: Це загальний термін для визначення будь-якого Об'єкта Спостереження, який НЕ є «вихідним Об'єктом Спостереження». Іншими словами, як внутрішні, так і зовнішні Об'єкти Спостереження вважаються «вхідними» Об'єктами Спостереження.

І нарешті, не всі оператори дотримуються концепції «внутрішніх» і «зовнішніх» Об'єктів Спостереження. Для деяких операторів, таких як `combineLatest` (ми побачимо це пізніше), усі Об'єкти Спостереження обробляються однаково, і тому ми називаємо кожен Об'єкт Спостереження «вхідним Об'єктом Спостереження».

### Let’s begin translating a few of these

Нижче наведено деякі з найпоширеніших операторів і способи тлумачення їхніх кулькових діаграм.

Ми почнемо з знайомого нам оператора `map()`.

![image](https://miro.medium.com/max/700/1*RUZNpZqArzCfc0UTjSZJ6A.png)

Верхня стрілка представляє наш вхідний Об'єкт Спостереження і видає три значення. Це досить просто, якщо ви працювали з функцією `map` використовуючи масиви JavaScript. Все, що ви робите, це трансформуєте значення, що надходять із вхідного Об'єкта Спостереження, у 10 разів. Ось кулькова діаграма, відтворена в коді:

```javascript
import { of } from "rxjs";
import { map } from "rxjs/operators";

const inputObservable = of(1, 2, 3);

inputObservable()
    .pipe(map((x) => 10 * x))
    .subscribe((value) => console.log(value));
```

![image](https://miro.medium.com/max/700/1*4Jg3vWN82T4R2N1QW4WJPg.gif)

Ми зробимо ще одну просту, а потім перейдемо до складніших. Нижче наведено оператор `take()`.

![image](https://miro.medium.com/max/700/1*cP6hRnkMKXtHsqvEu0qo5A.png)

На наведеній вище діаграмі вхідний Об'єкт Спостереження віддає чотири цілі числа — `1`, `2`, `3` і `4`. Якби ви підписалися на цей вхідний Об'єкт Спостереження напряму, ви б отримали ці чотири значення.

Але якщо ви передаєте оператор `take(2)` по каналу, новий вихідний Об'єкт Спостереження захопить перші два виданих значення, а потім завершиться. Вхідний Об'єкт Спостереження все ще видаватиме останні два значення, але наш вихідний Об'єкт Спостереження їх не бачитиме, оскільки він завершився після двох значень. Нижче наведено код і візуалізацію.

```javascript
import { interval } from "rxjs";
import { map, take } from "rxjs/operators";

const inputObservable = interval(1000);

inputObservable().pipe(take(2));
```

![image](https://miro.medium.com/max/700/1*k1suhVSk3QsosfOiyqBB3A.gif)
