# Об'єкти Спостереження

## Визначення

Об'єкти Спостереження — це ліниві колекції, що виштовхують дані з часом.

З визначення ми можемо виділити 3 пункти:

1. це колекції даних, які надходять з часом
2. вони виштовхують дані назовні
3. вони ліниві

Для того, щоб краще зрозуміти перший пункт, нам потрібно згадати масиви, які також є колекціями даних.

Єдина велика різниця, це те,
що масиви працють _синхронно_, а Об'єкти Спостереження _асинхронно_(з'являється поняття часу).

## Колекції даних, які надходять з часомі

В даній статті ми не будемо обговорювати всі тонкощі роботи з масивами, а згадаємо тільки речі, які допоможуть нам зрозуміти Об'єкти Спостереження краще.

Масив - це колекція даних. По-суті, це контейнер(`[]`), в який ми поміщаємо однорідні дані.

Звісно, ми можемо створювати масиви з абсолютно різними значеннями `['string', 3, {key: value}]`, але на практиці цього майже ніколи не робимо, тому що одна з переваг масивів в тому, що ми можемо робити ідентичні операції над кожним елементом масиву.

Для цього в нас є такі вбудовані методи масивів, як `Array.prototype.map`, `Array.prototype.filter`, `Array.prototype.reduce`, тощо.

Давайте подивимося на те, як ці методи працюють всередині.

```javascript
function map(array, projectionFn) {
	const newArray = [];

	for (let i = 0; i < array.length; i++) {
		newArray.push(projectionFn(array[i]));
	}
	return newArray;
}

const numbers = [1, 3, 9];
const multipliedByTwo = map(numbers, (x) => x * 2); // [2, 6, 18]
```

```javascript
function filter(array, predicateFn) {
	const newArray = [];

	for (let i = 0; i < array.length; i++) {
		if (predicateFn(array[i])) {
			newArray.push(array[i]);
		}
	}
	return newArray;
}

const numbers = [1, 3, 9];
const lessThanFive = filter(numbers, (x) => x < 5); // [1, 3]
```

Важливим моментом є те, що всі ці методи збудовані на засадах функціонального програмування:

1. Вони не мають побочних ефектів (чисті функції)
2. Вихідний результат залежить тільки від вхідних даних. Якщо ми безкінечну кількість разів викличемо функцію з однаковими вхідними
   параметрами - вона безкінечну кількість разів віддасть один результат.
3. Вони працюють з незмінними значеннями. Якщо ми передамо масив, як аргумент в функцію, то вона зробить копію і змінюватиме її. Сам масив завжди залишатиметься незмінним.
4. Вони часто повертають той же тип даних, який отримали через вхідні параметри. Це дозволяє нам створювати _ланцюги_ методів.

Всі ці пункти дають нам змогу дуже зручно працювати з масивами. Наприклад:

```javascript
const arr = [1, 2, 3, 4, 5, 6];
const composedArr = arr.map((x) => x + 1).filter((y) => y % 2 === 0); // [2,4,6];
```

В даному випадку в нас є масив чисел, який є вхідним параметром в метод `map()`, всередині цього методу ми застосовуємо функцію `x => x + 1` до кожного елементу масиву.

На виході ми отримуємо _новий масив_(масив `arr` залишається незмінним), який потрапляє як вхідний параметр в метод `filter()`, всередині якого ми до кожного елементу масиву застосовуємо функцію `y => y % 2 === 0` і на виході отримуємо _новий масив_, який і записуємо в змінну `composedArr`.

Зверніть увагу на те, що кожного разу ми отримуємо масив, як вхідний параметер, створюємо новий масив і віддаємо його. Це значить, що ми можемо розбивати цей ланцюг де захочемо і він залишиться робочим, тому що **жодний** метод не змінює вхідний масив.

```javascript
const arr = [1, 2, 3, 4, 5, 6];
const incrementedArr = arr.map((x) => x + 1);
const evenNumbersArr = arr.filter((y) => y % 2 === 0);
const oddNumberArr = arr.filter((y) => y % 2 !== 0);
```

В даному випадку ми розбили ланцюг на 2 частини. Спочатку ми додали до кожного елементу масиву одиницю. А потім масив `arr` відфільтрували 2 рази і отримали окремо масив з парними і непарними числами.

### Об'єкти Спостереження і Масиви

Хорошою ментальною моделлю для Об'єктів Спостереження є їх схожість на асинхронні масиви.
Подумайте про метод `Array.prototype.forEach`. Що він робить? Він використовує функцію зворотного виклику та виконує її один раз для кожного елемента в масиві.

Це робиться **синхронно**.

```javascript
const arr = [1, 2, 3, 4, 5];

arr.forEach((element) => console.log(element));

// 1,2,3,4,5
```

Нічого шокуючого. Давайте додамо асинхронність.
Подумайте, як працює цей код:

```javascript
const someDomElement = document.getElementById('someDomElement');

const handle = someDomElement.addEventListener('click', (event) => {
	console.log('got a click event');
});

// assuming the user clicks on someDomElement 5 times, you'll see
// got a click event
// got a click event
// got a click event
// got a click event
// got a click event
```

Ми передали функцію зворотного виклику в `addEventListener`, яка викликається кожного разу, коли подія `click` відбувається на елементі з ідентифікатором `someDomElement`. Це дуже схоже на те, що цей обробник викликається **_для кожної_** події `click`...

`addEventListener` діє як функція `forEach` для цього елемента DOM, яка викликається кожного разу, коли відбувається подія `click`. Єдина концептуальна відмінність між цим прикладом і `Array.prototype.forEach` полягає в тому, що обробник подій працює **_асинхронно_**.

Уявіть, що ви створюєте клон Netflix. У Netflix є багато фільмів. Ось не дуже випадковий вибір із чотирьох фільмів, оскільки вони можуть бути представлені в додатку, який незрозумілим чином рекомендує лише фільми 1980-х років. Оскільки JSON громіздкий, давайте також представимо ці фільми кольоровими кульками.

![img](https://miro.medium.com/max/875/1*8F8zfEvUa5YXrpi4oQMldw.png)

Зараз у цих фільмах немає нічого особливого. Припустімо, що ми випадково заглянули в цю частину нашої бази даних і знайшли ці чотири фільми. Особливих стосунків між ними немає. Без контексту.

Але тепер давайте помістимо їх у контейнер. Давайте використаємо масив, щоб умістити всі ці фільми.

![img](https://miro.medium.com/max/875/1*cKbFubKMuZvKEaPw9CBA6g.png)

Тепер у нас є дещо. Цей масив може представляти улюблені фільми нашого улюбленого вигаданого користувача Мері. Або вони можуть представляти чотири найпопулярніші фільми 80-х років. Справа в тому, що тепер у нас є певний логічний контекст для роздумів про ці фільми, оскільки ми помістили їх у масив. Це щось означає для нас, коли ми дивимося на цей масив. _Гей, це улюблені фільми Мері!_

Але є ще щось. Є також інженерна перевага контейнерування цих фільмів. Оскільки `Array.prototype` надає такі методи, як `map` і `filter`, тепер ми можемо виконувати агреговані операції над фільмами, створюючи методи для їхнього контейнера.

![img](https://miro.medium.com/max/875/1*TZ7sY3bo00P2eklyiTltFA.png)

Розмістивши фільми всередині колекції, ми тепер можемо створювати операції з цією колекцією, такі як `map`, `filter`, `concat` тощо.

Xочете отримати назви фільмів? Допоможе `map`. Хочете лише фільми покійного, великого Джона Г’юза? Фільтруйте із задоволенням.

Але як щодо подій? Javascript не дав нам можливості контейнеризувати події! Що, якщо нам знадобиться зробити запит `xhr`, щоб отримати кожен із цих фільмів із нашого API? Як ми можемо контейнеризувати значення, які надходять з часом?

<figure>
<img src="https://miro.medium.com/max/875/1*-Z9m_wW3o5lwGGwsSUHm6g.png" alt="" >
<figcaption align = "center"><b>Потік даних, що приходять з часом.</b></figcaption>
</figure>

Звичайно, за допомогою Об'єктів Спостереження. Це їх фундаментальна перевага, вони дозволяють контейнеризувати та створювати асинхронні події.

<figure>
<img src="https://miro.medium.com/max/875/1*WtyY4UIpw0hh7ofH-JDs6w.png" alt="" >
<figcaption align = "center"><b>Об'єкти Спостереження дають нам контейнеризувати асинхронний потік подій. В даному випадку, це список улюблених фільмів користувача.</b></figcaption>
</figure>

У випадку, коли цей Об'єкт Спостереження представляє улюблені відео Мері, це ідеально!

Можливо, вона зараз клацає по програмі, додаючи десятки відео до улюблених. За допомогою Об'єкту Спостереження ми можемо моделювати це як потік і постійно оновлювати інтерфейс користувача списком її вибраних відео.

<figure>
<img src="https://miro.medium.com/max/875/1*k9rc7JAaDvYMqwc8dQgsPw.png" alt="" >
<figcaption align = "center"><b>Асинхронність не повинна обмежувати нас!</b></figcaption>
</figure>

І, звісно, оскільки Об'єкти Спостереження доповнюються великою кількістю операторів, то ми можемо компонувати операції над цим потоком.

Якщо цей стиль композиції для вас новий, ось трюк, який може допомогти вам розвинути інтуїцію під час роботи з масивами.

### Уникайте циклів, якщо у вас є вибір.

Чому?

Розглянемо завдання фільтрування колекції фільмів за режисером і зіставлення лише з їхніми назвами та роком:

```javascript
favoriteMovies.filter((movie) => movie.director === 'John Hughes').map((movie) => ({ name: movie.name, year: movie.year }));

// We end up with a container with the values:
// { name: "The Breakfast Club", year: 1986 }
// { name: "Ferris Bueller's Day Off", year: 1987 }
```

Тепер запитайте себе наступне:

_Колекція (favoriteMovies), з якою працює код, є синхронною чи асинхронною?_

Ви насправді не знаєте, чи не так?

Ну ось і вся суть! Масиви мають `map` та `filter`, але ми тільки що відмітили, що Об'єкти Спостереження також мають їх. Звичайно, якби я додав цей рядок:
`const favoriteMovies = [{}...{}];`

Тоді ви зрозумієте, що він працює через синхронний масив. Але просто поглянувши на операції, що виконуються (`filter`, потім `map`), ви не уявляєте, які деталі їх реалізації. Ви просто знаєте, що контейнер фільтрується, а потім відображається. Може бути асинхронним, може бути синхронним. Це перевага написання декларативного коду над імперативним.

Порівняйте вищезазначене з цим:

```javascript

let favoriteMovies = [
  { title: ‘The Breakfast Club’, year: 1986, director: ‘John Hughes’,
  cast: [ ‘Ally Sheedy’, ‘Emilio Estevez’, ‘Judd Nelson’]
  },
  { title: “ferris buellers day off”, year: 1987, director: ‘John Hughes’,
  cast: [ ‘Matthew Broderick’, ‘Mia Sara’, ‘Alan Ruck’]
  },
  { title: ‘Wargames’, year: 1983, director: ‘John Badham’,
  cast: [ ‘Matthew Broderick’,‘Ally Sheedy’]
  }
];

let filteredAndMappedArray = [];

for (let i = 0; i < favoriteMovies.length; i++) {
  if (favoriteMovies[i].director === "John Hughes") {
    let mapped = {
      name: favoriteMovies[i].name,
      year: favoriteMovies[i].year
    };

    filteredAndMappedArray.push(mapped);
  }
}

// We end up with a (very synchronous) container with the values:
// { name: "The Breakfast Club", year: 1986 }
// { name: "Ferris Bueller's Day Off", year: 1987 }
// ...but we could've done better :)
```

Цикли настільки імперативні, наскільки це можливо, і вони практично вкарбовані в синхронний світ. Ви не можете міркувати про цикли на вищому рівні, тому що завжди будете грузнути в деталях реалізації.

## Виштовхування проти Витягання даних

Витягання(Pull) і Виштовхування(Push) — це два різні протоколи, які описують, як виробник даних може спілкуватися зі споживачем даних.

Що таке Витягання? У цій системі споживач визначає, коли він отримує дані від виробника. Сам Виробник не знає, коли дані будуть доставлені споживачу.

Кожна функція JavaScript є системою Витягання даних. Функція є виробником даних, і код, який викликає функцію, споживає їх, «витягуючи» єдине значення, що повертається з її виклику.

ES2015 також представив функції-генератори та ітератори (function\*). Код, який викликає `iterator.next()`, є споживачем, який «витягує» кілька значень з ітератора (виробника).

|                      | Виробник                                    | Споживач                                    |
| -------------------- | ------------------------------------------- | ------------------------------------------- |
| Витягання (Pull)     | Пасивний: створює дані за запитом           | **Активний:** вирішує, коли запитувати дані |
| Виштовхування (Push) | **Активний:** створює дані у власному темпі | Пасивний: реагує на отримані дані           |

Що таке Виштовхування? У цій системі виробник визначає, коли надсилати дані споживачеві. Споживач не знає, коли він отримає ці дані.

Обіцянки є найпоширенішим типом системи Виштовхування в JavaScript сьогодні. Обіцянка (виробник) віддає значення зареєстрованим зворотним викликам (споживачам), але, на відміну від функцій, саме Обіцянка відповідає за те, щоб точно визначити, коли це значення «виштовхується» до зворотних викликів.

RxJS представляє Об'єкти Спостереження (Observables), які належать до системи Виштовхування. Об'єкт Спостереження є виробником колекції значень, «виштовхуючи» їх до Спостерігачів (споживачів).

-   Функція — це обчислення з лінивим виконанням, яке синхронно повертає одне значення під час виклику.
-   Генератор — це обчислення з лінивим виконанням, яке синхронно повертає від нуля до (потенційно) нескінченних значень ітеративно.
-   Обіцянка — це обчислення, яке може (або не може) зрештою повернути одне значення асинхронно.
-   Об'єкт Спостереження — це обчислення з лінивим виконанням, яке може синхронно або асинхронно повертати від нуля до (потенційно) нескінченної кількості значень з моменту його виклику.

## Вони ліниві

Саме по собі, створення Об'єкту Спостереження нічого не робить, для того, щоб почати отримувати дані, нам потрібно на нього підписатися:

```javascript
import { Observable } from 'rxjs';

const observable = new Observable((subscriber) => {
	subscriber.next(1);
	subscriber.next(2);
	subscriber.next(3);
	setTimeout(() => {
		subscriber.next(4);
		subscriber.complete();
	}, 1000);
});

console.log('just before subscribe');
observable.subscribe({
	next: (x) => console.log('got value ' + x),
	error: (err) => console.error('something wrong occurred: ' + err),
	complete: () => console.log('done'),
});
console.log('just after subscribe');
```

В консолі ми побачимо:

```
just before subscribe
got value 1
got value 2
got value 3
just after subscribe
got value 4
done
```

### Об'єкти Спостереження як узагальнені функції??

> Об'єкти Спостереження схожі на функції без аргументів, які узагальнили для того, щоб вони могли віддати множину значень.

Зверніть увагу на наступне:

```javascript
function foo() {
	console.log('Hello');
	return 42;
}

const x = foo.call(); // те ж саме, що і foo()
console.log(x);
const y = foo.call(); // те ж саме, що і foo()
console.log(y);
```

Виведе наступне:

```
"Hello"
42
"Hello"
42
```

Ви можете написати ту саму поведінку вище, але з Об'єктом Спостереження:

```javascript
import { Observable } from 'rxjs';

const foo = new Observable((subscriber) => {
	console.log('Hello');
	subscriber.next(42);
});

foo.subscribe((x) => {
	console.log(x);
});
foo.subscribe((y) => {
	console.log(y);
});
```

Результат буде таким самим:

```
"Hello"
42
"Hello"
42
```

Це відбувається тому, що і функції, і Об'єкти Спостереження є ледачими обчисленнями. Якщо ви не викличете функцію, `console.log('Hello')` не відбудеться.

З Об'єктом Спостереження, якщо ви не «викликаєте» його (за допомогою `subscribe`), `console.log('Hello')` не відбудеться.

Крім того, «виклик» або «підписка» є окремою операцією: два виклики функцій викликають два окремих побічних ефекти, так само дві підписки Об'єктів Спостереження викликають два окремі побічні ефекти.

На відміну від EventEmitters, які мають спільні побічні ефекти та нетерпляче виконуються незалежно від наявності підписників, Об'єкти Спостереження не мають спільного виконання та є ледачими.

> Підписка на Об'єкт Спостереження є аналогом виклику Функції.

Дехто думає, що Об'єкти Спостереження є асинхронними. Це не правда. Наприклад:

```javascript
console.log('before');
console.log(foo.call());
console.log('after');
```

Ви побачите такий результат:

```
"before"
"Hello"
42
"after"
```

Те ж саме з Об'єктом Спостереження:

```javascript
console.log('before');
foo.subscribe((x) => {
	console.log(x);
});
console.log('after');
```

Виведе:

```
"before"
"Hello"
42
"after"
```

Що доводить, що підписка на `foo` була повністю синхронною, як і функція.

> Об'єкти Спостереження можуть віддавати значення як синхронно, так і асинхронно.

Яка різниця між Об'єктом Спостереження і функцією? Об'єкти Спостереження можуть «повертати» кілька значень з часом, чого функції не можуть. Ви не можете зробити це:

```javascript
function foo() {
	console.log('Hello');
	return 42;
	return 100; // dead code. will never happen
}
```

Функції можуть повертати лише одне значення. Об'єкти Спостереження, однак, можуть це зробити:

```javascript
import { Observable } from 'rxjs';

const foo = new Observable((subscriber) => {
	console.log('Hello');
	subscriber.next(42);
	subscriber.next(100); // "return" another value
	subscriber.next(200); // "return" yet another
});

console.log('before');
foo.subscribe((x) => {
	console.log(x);
});
console.log('after');
```

Поверне:

```
"before"
"Hello"
42
100
200
"after"
```

Але ви також можете "повертати" значення асинхронно:

```javascript
import { Observable } from 'rxjs';

const foo = new Observable((subscriber) => {
	console.log('Hello');
	subscriber.next(42);
	subscriber.next(100);
	subscriber.next(200);
	setTimeout(() => {
		subscriber.next(300); // happens asynchronously
	}, 1000);
});

console.log('before');
foo.subscribe((x) => {
	console.log(x);
});
console.log('after');
```

Виведе:

```
"before"
"Hello"
42
100
200
"after"
300
```

висновок:

`func.call()` означає "дайте мені одне значення синхронно"

`observable.subscribe()` означає "дайте мені будь-яку кількість значень, синхронно чи асинхронно"

Вони заповнюють пропущене місце в наступній таблиці:
| | Одне значення | Багато значень |
| --- | --- | --- |
| Витягання (Pull) | Функція | Ітератор |
| Виштовхування (Push) | Обіцянка | **Об'єкт Спостереження** |

## Анатомія Об'єкта Спостереження

Об'єкти Спостереження **створюються** за допомогою `new Observable` або оператора створення(`of(), from(), interval()` etc), на них можна **підписатися**, вони **виконуються** для доставки сповіщень `next`/`error`/`complete` до Спостерігача, і вони можуть **припинити** своє виконання.

Усі ці чотири аспекти закодовані в екземплярі Об'єкта Спостереження, але деякі з цих аспектів пов’язані з іншими типами, наприклад Спостерігач і Підписка.

Основні можливості Об'єкту Спостереження:

-   Створення Об'єктів Спостереження
-   Підписка на Об'єкти Спостереження
-   Виконання Об'єктів Спостереження
-   Утилізація Об'єктів Спостереження

### Створення Об'єктів Спостереження

Конструктор `Observable` приймає один аргумент: функцію `subscribe`.
У наступному прикладі створюється Об'єкт Спостереження, який щосекунди надсилає підписнику рядок «hi».

```javascript
import { Observable } from 'rxjs';

const observable = new Observable(function subscribe(subscriber) {
	const id = setInterval(() => {
		subscriber.next('hi');
	}, 1000);
});
```

У наведеному вище прикладі функція `subscribe` є найважливішою частиною для опису Об'єкту Спостереження. Давайте розглянемо, що вона означає.

### Підписка на Об'єкти Спостереження

На Об'єкт Спостереження `observable` у прикладі ми можемо підписатися таким чином:

```javascript
observable.subscribe({
	next: (x) => console.log(x),
	error: (err) => console.log('err', err),
	complete: () => console.log('Completed'),
});
```

Це не випадково, що `observable.subscribe` і `subscribe` в `new Observable(function subscribe(subscriber) {...})` мають однакові назви. У бібліотеці вони трошки відрізняються, але для практичних цілей ви можете вважати їх концептуально рівноправними.

Це показує, що виклики `subscribe` не використовуються одночано декількома Спостерігачами одного Об'єкту Спостереження. Під час виклику `observable.subscribe`, функція `subscribe` у `new Observable(function subscribe(subscriber) {...})` виконується _тільки_ для цього підписника. Кожен виклик `observable.subscribe` запускає власний незалежний виклик для кожного підписника.

> Підписка на Об'єкт Спостереження схожа на виклик функції, в яку ми аргументом передаємо зворотні виклики(callbacks), куди будуть доставлені дані.

Це суттєво відрізняється від WEB API обробників подій, таких як `addEventListener` / `removeEventListener`. З `observable.subscribe` даний Спостерігач не зареєстрований як слухач в Об'єкта Спостереження. Об'єкт Спостереження навіть не підтримує список приєднаних Спостерігачів.??

Виклик `subscribe` — це просто спосіб розпочати «виконання Об'єкту Спостереження» та доставити значення або події Спостерігачу цього виконання.

### Виконання Об'єктів Спостереження

Код усередині `new Observable(function subscribe(subscriber) {...})` представляє «виконання Об'єкту Спостереження», відкладене обчислення, яке відбувається лише для одного Спостерігача, який підписався. Виконання створює множину значень з часом (від 0 до безкінечності), синхронно чи асинхронно.

Існує три типи значень, які може надати?? виконання Об'єкту Спостереження:

-   `next` сповіщення: надсилає таке значення, як число, рядок, об’єкт тощо??.
-   `error` сповіщення: надсилає повідомлення про помилку JavaScript або виняток.
-   `complete` сповіщення: не надсилає значення.

Сповіщення `next` є найважливішим і найпоширенішим типом: вони представляють фактичні дані, які доставляються підписнику. Сповіщення `error` та `complete` можуть відбутися **_лише один раз_** під час виконання Об'єкту Спостереження, і може бути лише одне з них.

> У виконанні Об'єкту Спостереження може бути доставлено від нуля до нескінченності сповіщень `next`. Якщо доставлено сповіщення `error` або `complete`, після цього більше нічого не буде доставлено.

Нижче наведено приклад виконання Об'єкту Спостереження, який надсилає три сповіщення `next`, а потім завершується:

```javascript
import { Observable } from 'rxjs';

const observable = new Observable(function subscribe(subscriber) {
	subscriber.next(1);
	subscriber.next(2);
	subscriber.next(3);
	subscriber.complete();
});
```

Об'єкти Спостереження суворо дотримуються Observable Contract, тому наступний код не доставить сповіщення `subscriber.next(4)`:

```javascript
import { Observable } from 'rxjs';

const observable = new Observable(function subscribe(subscriber) {
	subscriber.next(1);
	subscriber.next(2);
	subscriber.next(3);
	subscriber.complete();
	subscriber.next(4); // Is not delivered because it would violate the contract
});
```

Гарною ідеєю буде загорнути будь-який код в функції `subscribe` блоком `try/catch`, який надсилатиме сповіщення про помилку, якщо отримає виняток:

```javascript
import { Observable } from 'rxjs';

const observable = new Observable(function subscribe(subscriber) {
	try {
		subscriber.next(1);
		subscriber.next(2);
		subscriber.next(3);
		subscriber.complete();
	} catch (err) {
		subscriber.error(err); // delivers an error if it caught one
	}
});
```

### Скасування виконання Об'єктів Спостереження

Оскільки виконання Об'єктів Спостереження може бути нескінченним, а Спостерігач зазвичай хоче перервати виконання в певний момент, нам потрібен API для скасування виконання.

Оскільки кожне виконання є ексклюзивним лише для одного Спостерігача, щойно Спостерігач закінчить отримання значень, він повинен мати спосіб зупинити виконання, щоб уникнути марної витрати обчислювальної потужності або ресурсів пам’яті.

Коли викликається `observable.subscribe`, Спостерігач прив'язується до щойно створеного виконання Об'єкту Спостереження. Цей виклик також повертає об’єкт, `Subscription`:

```javascript
const subscription = observable.subscribe((x) => console.log(x));
```

Підписка представляє поточне виконання та має мінімальний API, який дозволяє скасувати це виконання. За допомогою `subscription.unsubscribe()` ви можете скасувати поточне виконання:

```javascript
import { from } from 'rxjs';

const observable = from([10, 20, 30]);
const subscription = observable.subscribe((x) => console.log(x));
// Later:
subscription.unsubscribe();
```

> Коли ви підписуєтеся, ви отримуєте назад підписку, яка представляє поточне виконання. Просто викличте `unsubscribe()`, щоб скасувати виконання.

Кожен Об'єкт Спостереження повинен визначати, як розпоряджатися ресурсами цього виконання, коли ми створюємо Об'єкт Спостереження за допомогою `new Observable(function subscribe() {...})`. Ви можете зробити це, повернувши спеціальну функцію скасування підписки з функції `subscribe()`.??

Наприклад, ось як ми очищаємо інтервальне виконання за допомогою `setInterval`:

```javascript
const observable = new Observable(function subscribe(subscriber) {
	// Keep track of the interval resource
	const intervalId = setInterval(() => {
		subscriber.next('hi');
	}, 1000);

	// Provide a way of canceling and disposing the interval resource
	return function unsubscribe() {
		clearInterval(intervalId);
	};
});
```

Подібно до того, як `observable.subscribe` нагадує `new Observable(function subscribe() {...})`, функція `unsubscribe`, яку ми повертаємо з функції `subscribe`, концептуально дорівнює `subscription.unsubscribe`. Насправді, якщо ми видалимо типи ReactiveX, що оточують ці концепції, ми залишимо досить простий JavaScript.

```javascript
function subscribe(subscriber) {
	const intervalId = setInterval(() => {
		subscriber.next('hi');
	}, 1000);

	return function unsubscribe() {
		clearInterval(intervalId);
	};
}

const unsubscribe = subscribe({ next: (x) => console.log(x) });

// Later:
unsubscribe(); // dispose the resources
```

Причина, чому ми використовуємо типи Rx, такі як Об'єкт Спостереження, Спостерігач і Підписка, полягає в тому, щоб забезпечити безпеку (наприклад, Observable Contract) і можливість комбінування з операторами.
