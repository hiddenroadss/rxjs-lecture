# Об'єкти Спостереження

Об'єкти Спостереження — це ліниві колекції даних, які можуть надходити з часом. 

З визначення ми можемо виділити 2 основні пункти:
- це колекції даних, які надходять з часом
- вони ліниві

Для того, щоб краще зрозуміти першу частину, нам потрібно згадати масиви, які також є колекціями даних. Єдина велика різниця, це те,
що масиви працють *синхронно*, а Об'єкти Спостереження *асинхронно*(з'являється поняття часу).

## Масиви

В даній статті ми не будемо обговорювати всі тонкощі роботи з масивами, а згадаємо тільки речі, які допоможуть нам зрозуміти Об'єкти Спостереження краще.
1. Масив - це колекція даних. По-суті, це контейнер(`[]`), в який ми поміщаємо однорідні дані.
Звісно, ми можемо створювати масиви з абсолютно різними значеннями `['string', 3, {key: value}]`, але на практиці цього майже ніколи не робимо, тому що одна з переваг масивів в тому, що ми можемо робити ідентичні операції над кожним елементом масиву.
Для цього в нас є такі вбудовані методи масивів, як `Array.prototype.map`, `Array.prototype.filter`, `Array.prototype.reduce`, тощо.
Давайте подивимося на те, як ці методи працюють всередині.
```javascript
function map(array, projectionFn) {
  const newArray = [];

  for (let i = 0; i < array.length; i++) {
    newArray.push(projectionFn(array[i]));
  }
  return newArray;
}

const numbers = [1, 3, 9];
const multipliedByTwo = map(numbers, x => x * 2); // [2, 6, 18]

```

```javascript

function filter(array, predicateFn) {
  const newArray = [];

  for (let i = 0; i < array.length; i++) {
    if (predicateFn(array[i])) {
      newArray.push(array[i]);
    }
  }
  return newArray;
}

const numbers = [1, 3, 9];
const lessThanFive = filter(numbers, x => x < 5);
```

Важливим моментом є те, що всі ці методи збудовані на засадах функціонального програмування:
1. Вони не мають побочних ефектів (чисті функції)
2. Вихідний результат залежить тільки від вхідних даних. Якщо ми безкінечну кількість разів викличемо функцію з однаковими вхідними
параметрами - вона безкінечну кількість разів віддасть один результат.
3. Вони працюють з незмінними значеннями. Якщо ми передамо масив, як параметер в функцію, то вона зробить копію і змінюватиме її. Сам масив завжди залишатиметься незмінним.
4. Вони часто повертають той же тип даних, який отримали через вхідні параметри. Це дозволяє нам створювати *ланцюги* методів.
Всі ці пункти дають нам змогу дуже зручно працювати з масивами. Наприклад:
```javascript
const arr = [1,2,3,4,5,6];
const composedArr = arr.map(x => x + 1).filter(y => y % 2 === 0); // [2,4,6];
``` 
В даному випадку в нас є масив чисел, який є вхідним параметром в метод `map()`, всередині цього методу ми застосовуємо функцію `x => x + 1` до кожного елементу масиву.
На виході ми отримуємо *новий масив*(масив `arr` залишається незмінним), який потрапляє як вхідний параметр в метод `filter()`, всередині якого ми до кожного елементу масиву застосовуємо функцію `y => y % 2 === 0` і на виході отримуємо *новий масив*, який і записуємо в змінну `composedArr`.
Зверніть увагу на те, що кожного разу ми отримуємо масив, як вхідний параметер, створюємо новий масив і віддаємо його. Це значить, що ми можемо розбивати цей ланцюг де захочемо і він залишиться робочим, тому що **жодний** метод не змінює вхідний масив.
```javascript
const arr = [1,2,3,4,5,6];
const incrementedArr = arr.map(x => x + 1);
const evenNumbersArr = incrementedArr.filter(y => y % 2 === 0);
const oddNumberArr = incrementedArr.filter(y => y % 2 !== 0);
```
В даному випадку ми розбили ланцюг на 2 частини. Спочатку ми додали до кожного елементу масиву одиницю. А потім отриманий масив відфільтрували 2 рази і отримали окремо масив з парними і непарними числами.

## Somw
Хорошою ментальною моделлю для Об'єктів Спостереження є їх схожість на асинхронні масиви. 
Подумайте про метод `Array.prototype.forEach`. Що він робить? Він використовує функцію зворотного виклику та виконує її один раз для кожного елемента в масиві. Це робиться **синхронно**.

```javascript
const arr = [1,2,3,4,5];

arr.forEach(element => console.log(element));

// 1,2,3,4,5
```
Нічого шокуючого. Давайте додамо асинхронність.
Подумайте, як працює цей код:
```javascript
const someDomElement = document.getElementById('someDomElement');

const handle = someDomElement.addEventListener('click', (event) => { console.log('got a click event'); });

// assuming the user clicks on someDomElement 5 times, you'll see
// got a click event
// got a click event
// got a click event
// got a click event
// got a click event
```

Ми передали функцію зворотного виклику в `addEventListener`, яка викликається кожного разу, коли подія `click` відбувається на елементі з ідентифікатором `someDomElement`. Це дуже схоже на те, що цей обробник викликається `forEach` події `click`...
`addEventListener` діє як функція `forEach` для цього елемента DOM, яка викликається кожного разу, коли відбувається подія `click`. Єдина концептуальна відмінність між цим прикладом і `Array.prototype.forEach` полягає в тому, що обробник подій працює *асинхронно*.

Але ментальна модель по суті та сама; Якби тільки у нас був якийсь гарний контейнер, який ми могли б складати, як масиви, і який також міг би обробляти асинхронні дані, такі як події…
Як ми побачимо, ми зможемо створювати Об'єкти Спостереження та використовувати такі функції, як map і filter, подібно до того, що ми робили з масивами в попередній частині.
Давайте зупинимось і доведемо це порівняння до наступного рівня, щоб переконатися, що ми перейдемо до реалізації Об'єкта Спостереження в наступній статті з належним мисленням.

Уявіть, що ви створюєте клон Netflix. У Netflix є багато фільмів. Ось не дуже випадковий вибір із чотирьох фільмів, оскільки вони можуть бути представлені в додатку, який незрозумілим чином рекомендує лише фільми 1980-х років. Оскільки JSON громіздкий, давайте також представимо ці фільми кольоровими колами.
![img](https://miro.medium.com/max/875/1*8F8zfEvUa5YXrpi4oQMldw.png)

Зараз у цих фільмах немає нічого особливого. Припустімо, що ми випадково заглянули в цю частину нашої бази даних і знайшли ці чотири фільми. Особливих стосунків між ними немає. Без контексту.

Але тепер давайте помістимо їх у контейнер. Давайте використаємо масив, щоб умістити всі ці фільми.
![img](https://miro.medium.com/max/875/1*cKbFubKMuZvKEaPw9CBA6g.png)

Тепер у нас є дещо. Цей масив може представляти улюблені фільми нашого улюбленого вигаданого користувача Мері. Або вони можуть представляти чотири найпопулярніші фільми 80-х років. Справа в тому, що тепер у нас є певний логічний контекст для роздумів про ці фільми, оскільки ми помістили їх у масив. Це щось означає для нас, коли ми дивимося на цей масив. *Гей, це улюблені фільми Мері!*

Але є ще щось. Є також інженерна перевага контейнерування цих фільмів. Оскільки ``Array.prototype` надає такі методи, як `map` і `filter`, тепер ми можемо виконувати агреговані операції над фільмами, створюючи методи для їхнього контейнера.
![img](https://miro.medium.com/max/875/1*TZ7sY3bo00P2eklyiTltFA.png)
Розмістивши фільми всередині колекції, ми тепер можемо створювати операції з цією колекцією, такі як `map`, `filter`, `concat` тощо.

Xочете отримати назви? Допоможе `map`. Хочете лише фільми покійного, великого Джона Г’юза? Фільтруйте із задоволенням.

Але як щодо подій? Javascript не дав нам можливості контейнеризувати події! Що, якщо нам знадобиться зробити запит `xhr`, щоб отримати кожен із цих фільмів із нашого  API? Як ми можемо контейнеризувати значення, які надходять з часом?
![img](https://miro.medium.com/max/875/1*-Z9m_wW3o5lwGGwsSUHm6g.png)
A stream of values arriving over time.
Звичайно, за допомогою Об'єктів Спостереження. Це їх фундаментальна перевага, вони дозволяють контейнеризувати та створювати асинхронні події.
![img](https://miro.medium.com/max/875/1*WtyY4UIpw0hh7ofH-JDs6w.png)
Observables let us containerize an async stream of events. In this case, a user’s list of favorited movies.

У випадку, коли цей Об'єкт Спостереження представляє улюблені відео Мері, це ідеально! Можливо, вона зараз клацає по програмі, додаючи десятки відео до улюблених. За допомогою Об'єкту Спостереження ми можемо моделювати це як потік і постійно оновлювати інтерфейс користувача списком її вибраних відео.
![img](https://miro.medium.com/max/875/1*k9rc7JAaDvYMqwc8dQgsPw.png)
Asynchrony shall not floor us!

І, звісно, оскільки Об'єкти Спостереження доповнюються великою кількістю операторів, то ми можемо компонувати операції над цим потоком.

Якщо цей стиль композиції для вас новий, ось трюк, який може допомогти вам розвинути інтуїцію під час роботи з масивами.

### Уникайте циклів, якщо у вас є вибір.
Чому? Дивіться.

Розглянемо завдання фільтрування колекції фільмів за режисером і зіставлення лише з їхніми назвами та роком:
```javascript
favoriteMovies.filter(movie => movie.director === "John Hughes")
              .map(movie => ({name: movie.name, year: movie.year}));

// We end up with a container with the values:
// { name: "The Breakfast Club", year: 1986 }
// { name: "Ferris Bueller's Day Off", year: 1987 }
```
Тепер запитайте себе наступне:

*Колекція (favoriteMovies), з якою працює код, є синхронною чи асинхронною?*

Ви насправді не знаєте, чи не так?

Ну ось і вся суть! Масиви мають `map` та `filter`, але ми тільки що відмітили, що Об'єкти Спостереження також мають їх. Звичайно, якби я додав цей рядок:
`const favoriteMovies = [{}...{}];`

Тоді ви зрозумієте, що він працює через синхронний масив. Але просто поглянувши на операції, що виконуються (`filter`, потім `map`), ви не уявляєте, які деталі їх реалізації. Ви просто знаєте, що контейнер фільтрується, а потім відображається. Може бути асинхронним, може бути синхронним. Це перевага написання декларативного коду над імперативним.

Порівняйте вищезазначене з цим:
```javascript

let favoriteMovies = [
  { title: ‘The Breakfast Club’, year: 1986, director: ‘John Hughes’,
  cast: [ ‘Ally Sheedy’, ‘Emilio Estevez’, ‘Judd Nelson’]
  },
  { title: “ferris buellers day off”, year: 1987, director: ‘John Hughes’,
  cast: [ ‘Matthew Broderick’, ‘Mia Sara’, ‘Alan Ruck’]
  },
  { title: ‘Wargames’, year: 1983, director: ‘John Badham’,
  cast: [ ‘Matthew Broderick’,‘Ally Sheedy’]
  } 
];

let filteredAndMappedArray = [];

for (let i = 0; i < favoriteMovies.length; i++) {
  if (favoriteMovies[i].director === "John Hughes") {
    let mapped = {
      name: favoriteMovies[i].name,
      year: favoriteMovies[i].year
    };
    
    filteredAndMappedArray.push(mapped);
  }
}

// We end up with a (very synchronous) container with the values:
// { name: "The Breakfast Club", year: 1986 }
// { name: "Ferris Bueller's Day Off", year: 1987 }
// ...but we could've done better :)
```
Великий сюрприз! Цикли настільки імперативні, наскільки це можливо, і вони практично вкарбовані в синхронний світ. Ви не можете міркувати про цикли на вищому рівні, тому що завжди будете грузнути в деталях реалізації.

Як ми побачимо, Об'єкти Спостереження звільняють нас від цього тягаря, коли ми маємо справу з асинхронними даними.

Вони заповнюють пропущене місце в наступній таблиці:
| | Single | Multiple |
| --- | --- | --- |
| Pull | Функція | Ітератор |
| Push | Обіцянка | **Об'єкт Спостереження** |

Приклад. Нижче наведено Об'єкт Спостереження, який надсилає значення 1, 2, 3 негайно (синхронно) під час підписки, а значення 4 після того, як мине одна секунда після виклику підписки, а потім завершується:
```javascript
import { Observable } from 'rxjs';

const observable = new Observable(subscriber => {
  subscriber.next(1);
  subscriber.next(2);
  subscriber.next(3);
  setTimeout(() => {
    subscriber.next(4);
    subscriber.complete();
  }, 1000);
```
Саме по собі, створення Об'єкту Спостереження нічого не робить, для того, щоб почати отримувати дані, нам потрібно на нього підписатися:
```javascript
import { Observable } from 'rxjs';

const observable = new Observable(subscriber => {
  subscriber.next(1);
  subscriber.next(2);
  subscriber.next(3);
  setTimeout(() => {
    subscriber.next(4);
    subscriber.complete();
  }, 1000);
});

console.log('just before subscribe');
observable.subscribe({
  next: (x) => console.log('got value ' + x),
  error: (err) => console.error('something wrong occurred: ' + err),
  complete: () => console.log('done')
});
console.log('just after subscribe');
```
В консолі ми побачимо:
```
just before subscribe
got value 1
got value 2
got value 3
just after subscribe
got value 4
done
```
## Pull vs Push
Pull і Push — це два різні протоколи, які описують, як виробник даних може спілкуватися зі споживачем даних.

Що таке Pull? У системах Pull споживач визначає, коли він отримує дані від виробника. Сам Виробник не знає, коли дані будуть доставлені Споживачу.
Кожна функція JavaScript є системою Pull. Функція є виробником даних, і код, який викликає функцію, споживає їх, «витягуючи» єдине значення, що повертається з її виклику.

ES2015 представив функції-генератори та ітератори (function*), інший тип Pull-системи. Код, який викликає iterator.next(), є споживачем, який «витягує» кілька значень з ітератора (виробника).

| | Виробник | Споживач |
| --- | --- | --- |
| Pull | Пасивний: створює дані за запитом | **Активний:** вирішує, коли запитувати дані |
| Push | **Активний:** створює дані у власному темпі  | Пасивний: реагує на отримані дані |

Що таке Push? У системах Push виробник визначає, коли надсилати дані споживачеві. Споживач не знає, коли він отримає ці дані.
Обіцянки є найпоширенішим типом Push-системи в JavaScript сьогодні. Обіцянка (виробник) надає дозволене значення зареєстрованим зворотним викликам (споживачам), але, на відміну від функцій, саме проміс відповідає за те, щоб точно визначити, коли це значення «виштовхується» до зворотних викликів.

RxJS представляє Об'єкти Спостереження(Observables), нову систему Push для JavaScript. Об'єкт Спостереження є виробником колекції значень, «виштовхуючи» їх до спостерігачів (споживачів).
- Функція — це обчислення з лінивим виконанням, яке синхронно повертає одне значення під час виклику. 
- Генератор — це обчислення з лінивим виконанням, яке синхронно повертає від нуля до (потенційно) нескінченних значень ітеративно.
- Обіцянка — це обчислення, яке може (або не може) зрештою повернути одне значення. 
- Об'єкт Спостереження — це обчислення з лінивим виконанням, яке може синхронно або асинхронно повертати від нуля до (потенційно) нескінченної кількості значень з моменту його виклику.

## Об'єкти Спостереження як узагальнення функцій
Всупереч популярним твердженням, Об'єкти Спостереження не схожі на EventEmitters і не схожі на Promises для кількох значень. У деяких випадках Об'єкти Спостереження можуть діяти як EventEmitters, а саме, коли вони багатоадресні за допомогою RxJS Subjects, але зазвичай вони не діють як EventEmitters.

> Об'єкти Спостереження схожі на функції з нульовими аргументами, але узагальніть їх, щоб дозволити кілька значень.

Зверніть увагу на наступне:
```javascript
function foo() {
  console.log('Hello');
  return 42;
}

const x = foo.call(); // те ж саме, що і foo()
console.log(x);
const y = foo.call(); // те ж саме, що і foo()
console.log(y);
```
Виведе наступне:
```
"Hello"
42
"Hello"
42
```
Ви можете написати ту саму поведінку вище, але з Об'єктом Спостереження:
```javascript
import { Observable } from 'rxjs';

const foo = new Observable(subscriber => {
  console.log('Hello');
  subscriber.next(42);
});

foo.subscribe(x => {
  console.log(x);
});
foo.subscribe(y => {
  console.log(y);
});
```
Результат буде таким самим:
```
"Hello"
42
"Hello"
42
```
Це відбувається тому, що і функції, і Об'єкти Спостереження є ледачими обчисленнями. Якщо ви не викличете функцію, `console.log('Hello')` не відбудеться. Крім того, з Об'єктом Спостереження, якщо ви не «викликаєте» його (за допомогою `subscribe`), `console.log('Hello')` не відбудеться. Крім того, «виклик» або «підписка» є окремою операцією: два виклики функцій викликають два окремих побічних ефекту, а дві підписки Об'єктів Спостереження викликають два окремі побічні ефекти. На відміну від EventEmitters, які мають спільні побічні ефекти та нетерпляче виконуються незалежно від наявності підписників, Об'єкти Спостереження не мають спільного виконання та є ледачими.

> Підписування на Об'єкт Спостереження є аналогом виклику Функції.

Деякі люди стверджують, що Об'єкти Спостереження є асинхронними. Це не правда. Наприклад:
```javascript
console.log('before');
console.log(foo.call());
console.log('after');
```
Ви побачите такий результат:
```
"before"
"Hello"
42
"after"
```
Те ж саме з Об'єктом Спостереження:
```javascript
console.log('before');
foo.subscribe(x => {
  console.log(x);
});
console.log('after');
```
Виведе:
```
"before"
"Hello"
42
"after"
```
Що доводить, що підписка на foo була повністю синхронною, як і функція.

> Об'єкти Спостереження можуть віддавати значення як синхронно, так і асинхронно.

Яка різниця між Об'єкт Спостереження і функцією? Спостережувані можуть «повертати» кілька значень з часом, чого функції не можуть. Ви не можете зробити це:
```javascript
function foo() {
  console.log('Hello');
  return 42;
  return 100; // dead code. will never happen
}
```
Функції можуть повертати лише одне значення. Об'єкти Спостереження, однак, можуть це зробити:
```javascript
import { Observable } from 'rxjs';

const foo = new Observable(subscriber => {
  console.log('Hello');
  subscriber.next(42);
  subscriber.next(100); // "return" another value
  subscriber.next(200); // "return" yet another
});

console.log('before');
foo.subscribe(x => {
  console.log(x);
});
console.log('after');
```
Поверне:
```
"before"
"Hello"
42
100
200
"after"
```
Але ви також можете "повертати" значення асинхронно:
```javascript
import { Observable } from 'rxjs';

const foo = new Observable(subscriber => {
  console.log('Hello');
  subscriber.next(42);
  subscriber.next(100);
  subscriber.next(200);
  setTimeout(() => {
    subscriber.next(300); // happens asynchronously
  }, 1000);
});

console.log('before');
foo.subscribe(x => {
  console.log(x);
});
console.log('after');
```
Виведе:
```
"before"
"Hello"
42
100
200
"after"
300
```
висновок:
`func.call()` означає "дайте мені одне значення синхронно" 
`observable.subscribe()` означає "дати мені будь-яку кількість значень, синхронно чи асинхронно"

## Анатомія Об'єкту Спостереження
Об'єкти Спостереження **створюються** за допомогою `new Observable` або оператора створення(`of(), from(), interval()` etc), на них підписується Спостерігач, **виконуються** для доставки сповіщень `next`/`error`/`complete` до Спостерігача, і їхнє виконання може бути припинено. Усі ці чотири аспекти закодовані в екземплярі Об'єкту Спостереження, але деякі з цих аспектів пов’язані з іншими типами, наприклад Спостерігач і Підписка.
Основні завдання Об'єкту Спостереження:
- Створення Об'єктів Спостереження 
- Підписка на Об'єкти Спостереження 
- Виконання Об'єктів Спостереження 
- Утилізація Об'єктів Спостереження
### Створення Об'єктів Спостереження
Конструктор Observable приймає один аргумент: функцію `subscribe`.
У наступному прикладі створюється Observable, який щосекунди надсилає передплатнику рядок «hi».
```javascript
import { Observable } from 'rxjs';

const observable = new Observable(function subscribe(subscriber) {
  const id = setInterval(() => {
    subscriber.next('hi')
  }, 1000);
});
```
У наведеному вище прикладі функція підписки є найважливішою частиною для опису Observable. Давайте розглянемо, що означає підписка.
### Subscribing to Observables
Обсервабель Observable у прикладі можна підписатися на такий:
```javascript
observable.subscribe(x => console.log(x));
```
Це не випадково, що `observable.subscribe` і `subscribe` в `new Observable(function subscribe(subscriber) {...})` мають однакові назви. У бібліотеці вони різні, але для практичних цілей ви можете вважати їх концептуально рівноправними.
Це показує, як виклики підписки не розподіляються між декількома спостерігачами одного Observable. Під час виклику `observable.subscribe` за допомогою Observer функція `subscribe` у `new Observable(function subscribe(subscriber) {...})` виконується для цього передплатника. Кожен виклик `observable.subscribe` запускає власну незалежну установку для цього передплатника.
Підписка на Observable схожа на виклик функції, надаючи зворотні виклики, куди будуть доставлені дані.
Це суттєво відрізняється від API обробників подій, таких як addEventListener / removeEventListener. З `observable.subscribe` даний Observer не зареєстрований як слухач у Observable. Observable навіть не підтримує список приєднаних спостерігачів.
Виклик підписки — це просто спосіб розпочати «спостережуване виконання» та доставити значення або події спостерігачу цього виконання.
### Executing Observable
Код усередині `new Observable(function subscribe(subscriber) {...})` представляє «виконання Observable», відкладене обчислення, яке відбувається лише для кожного спостерігача, який підписався. Виконання створює кілька значень з часом, синхронно чи асинхронно.
Існує три типи значень, які може надати спостережуване виконання:
- «Наступне» сповіщення: надсилає таке значення, як число, рядок, об’єкт тощо. 
- Сповіщення про помилку: надсилає повідомлення про помилку JavaScript або виняток. 
- «Повне» сповіщення: не надсилає значення.
Сповіщення «Далі» є найважливішим і найпоширенішим типом: вони представляють фактичні дані, які доставляються абоненту. Сповіщення «Помилка» та «Завершено» можуть відбутися лише один раз під час спостережуваного виконання, і може бути лише одне з них.
У спостережуваному виконанні можуть бути доставлені наступні сповіщення від нуля до нескінченності. Якщо доставлено сповіщення про помилку або завершено, після цього більше нічого не буде доставлено.
Нижче наведено приклад виконання Observable, яке надсилає три сповіщення Next, а потім завершує:
```javascript
import { Observable } from 'rxjs';

const observable = new Observable(function subscribe(subscriber) {
  subscriber.next(1);
  subscriber.next(2);
  subscriber.next(3);
  subscriber.complete();
});
```
Observables суворо дотримуються Observable Contract, тому наступний код не доставить наступне сповіщення 4:
```javascript
import { Observable } from 'rxjs';

const observable = new Observable(function subscribe(subscriber) {
  subscriber.next(1);
  subscriber.next(2);
  subscriber.next(3);
  subscriber.complete();
  subscriber.next(4); // Is not delivered because it would violate the contract
});
```
Гарною ідеєю буде загорнути будь-який код у підписку блоком `try/catch`, який надсилатиме сповіщення про помилку, якщо виловить виняток:
```javascript
import { Observable } from 'rxjs';

const observable = new Observable(function subscribe(subscriber) {
  try {
    subscriber.next(1);
    subscriber.next(2);
    subscriber.next(3);
    subscriber.complete();
  } catch (err) {
    subscriber.error(err); // delivers an error if it caught one
  }
});
```
### Disposing  Observable Execution
Оскільки спостережувані виконання можуть бути нескінченними, а спостерігач зазвичай хоче перервати виконання за кінцевий час, нам потрібен API для скасування виконання. Оскільки кожне виконання є ексклюзивним лише для одного спостерігача, щойно спостерігач закінчить отримання значень, він повинен мати спосіб зупинити виконання, щоб уникнути марної витрати обчислювальної потужності або ресурсів пам’яті.
Коли викликається observable.subscribe, Observer приєднується до щойно створеного виконання Observable. Цей виклик також повертає об’єкт, Subscription:
```javascript
const subscription = observable.subscribe(x => console.log(x));
```
Підписка представляє поточне виконання та має мінімальний API, який дозволяє скасувати це виконання. Детальніше про тип підписки читайте тут. За допомогою `subscription.unsubscribe()` ви можете скасувати поточне виконання:
```javascript
import { from } from 'rxjs';

const observable = from([10, 20, 30]);
const subscription = observable.subscribe(x => console.log(x));
// Later:
subscription.unsubscribe();
```
Коли ви підписуєтеся, ви отримуєте назад підписку, яка представляє поточне виконання. Просто викличте `unsubscribe()`, щоб скасувати виконання.
Кожен Observable повинен визначати, як розпоряджатися ресурсами цього виконання, коли ми створюємо Observable за допомогою create(). Ви можете зробити це, повернувши спеціальну функцію скасування підписки з функції `subscribe()`.
Наприклад, ось як ми очищаємо набір інтервальних виконання за допомогою `setInterval`:
```javascript
const observable = new Observable(function subscribe(subscriber) {
  // Keep track of the interval resource
  const intervalId = setInterval(() => {
    subscriber.next('hi');
  }, 1000);

  // Provide a way of canceling and disposing the interval resource
  return function unsubscribe() {
    clearInterval(intervalId);
  };
});
```
Подібно до того, як observable.subscribe нагадує `new Observable(function subscribe() {...})`, `unsubscribe`, який ми повертаємо з `subscribe`, концептуально дорівнює `subscription.unsubscribe`. Насправді, якщо ми видалимо типи ReactiveX, що оточують ці концепції, ми залишимо досить простий JavaScript.
```javascript
function subscribe(subscriber) {
  const intervalId = setInterval(() => {
    subscriber.next('hi');
  }, 1000);

  return function unsubscribe() {
    clearInterval(intervalId);
  };
}

const unsubscribe = subscribe({next: (x) => console.log(x)});

// Later:
unsubscribe(); // dispose the resources
```
Причина, чому ми використовуємо типи Rx, такі як Observable, Observer і Subscription, полягає в тому, щоб забезпечити безпеку (наприклад, Observable Contract) і можливість комбінування з операторами.
