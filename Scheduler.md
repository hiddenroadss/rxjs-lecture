# Scheduler
Що таке Планувальник? Планувальник контролює, коли починається підписка та коли надходять сповіщення. Він складається з трьох компонентів.

- Планувальник — це структура даних. Він знає, як зберігати та ставити завдання в чергу на основі пріоритету чи інших критеріїв.
- Планувальник – це контекст виконання. Він позначає, де і коли виконується завдання (наприклад, негайно або в іншому механізмі зворотного виклику, наприклад `setTimeout` або `process.nextTick`, або кадр анімації).
- Планувальник має (віртуальний) годинник. Він надає поняття «час» методом `now()` у планувальнику. Завдання, заплановані на певному планувальнику, дотримуватимуться лише часу, позначеного цим годинником.
- Планувальник дозволяє визначити, у якому контексті виконання Об'єкт Спостереження доставлятиме сповіщення своєму Спостерігачу.

У наведеному нижче прикладі ми беремо звичайний простий Об'єкт Спостереження, який видає значення `1`, `2`, `3` синхронно, і використовуємо оператор `observOn`, щоб вказати асинхронний планувальник, який буде використовуватися для доставки цих значень.

```javascript
import { Observable, observeOn, asyncScheduler } from 'rxjs';

const observable = new Observable((observer) => {
  observer.next(1);
  observer.next(2);
  observer.next(3);
  observer.complete();
}).pipe(
  observeOn(asyncScheduler)
);

console.log('just before subscribe');
observable.subscribe({
  next(x) {
    console.log('got value ' + x);
  },
  error(err) {
    console.error('something wrong occurred: ' + err);
  },
  complete() {
    console.log('done');
  },
});
console.log('just after subscribe');
```

Який виконується з виводом:
```
just before subscribe
just after subscribe
got value 1
got value 2
got value 3
done
```

Зверніть увагу, як сповіщення `got value...` були доставлені відразу *після* підписки, що відрізняється від поведінки за замовчуванням, яку ми бачили досі. Це тому, що `observOn(asyncScheduler)` вводить проксі-спостерігач між новим Об'єктом Спостереження і остаточним Спостерегачем. Давайте перейменуємо деякі ідентифікатори, щоб зробити цю відмінність очевидним у прикладі коду:

```javascript
import { Observable, observeOn, asyncScheduler } from 'rxjs';

const observable = new Observable((proxyObserver) => {
  proxyObserver.next(1);
  proxyObserver.next(2);
  proxyObserver.next(3);
  proxyObserver.complete();
}).pipe(
  observeOn(asyncScheduler)
);

const finalObserver = {
  next(x) {
    console.log('got value ' + x);
  },
  error(err) {
    console.error('something wrong occurred: ' + err);
  },
  complete() {
    console.log('done');
  },
};

console.log('just before subscribe');
observable.subscribe(finalObserver);
console.log('just after subscribe');
```

ProxyObserver створюється в `ObservOn(asyncScheduler)`, а його функція `next(val)` виглядає приблизно так:
```javascript
const proxyObserver = {
  next(val) {
    asyncScheduler.schedule(
      (x) => finalObserver.next(x),
      0 /* delay */,
      val /* will be the x for the function above */
    );
  },

  // ...
};
```

Асинхронний планувальник працює з `setTimeout` або `setInterval`, навіть якщо задана затримка дорівнює нулю. Як зазвичай, у JavaScript `setTimeout(fn, 0)` запускає функцію `fn` найпершою під час наступної ітерації циклу подій. Це пояснює, чому отримане значення 1 доставляється до `finalObserver` одразу після підписки.

Метод `schedule()` планувальника приймає аргумент затримки, який посилається на кількість часу відносно внутрішнього годинника планувальника. Годинник планувальника не обов’язково має бути пов’язаний із фактичним часом настінного годинника. Таким чином часові оператори, такі як затримка, діють не на фактичний час, а на час, який диктує годинник Планувальника. Це особливо корисно під час тестування, коли віртуальний планувальник часу може використовуватися для підробки часу настінного годинника, а насправді виконує заплановані завдання синхронно.

## Типи Планувальників

Асинхронний планувальник є одним із вбудованих планувальників, наданих RxJS. Кожен із них можна створити та повернути за допомогою статичних властивостей об’єкта Планувальник.

| ПЛАНІВНИК | ПРИЗНАЧЕННЯ
| --- | --- |
| `null` | Якщо не передати жодного планувальника, сповіщення доставляються синхронно та рекурсивно. Використовуйте це для операцій із постійним часом або хвостових рекурсивних операцій.
| `queueScheduler` | Розклад у черзі в кадрі поточної події (батутний планувальник). Використовуйте це для ітераційних операцій.
| `asapScheduler` | Планує мікрочергу завдань, яка є тією самою чергою, що використовується для Обіцянок. В основному після поточної задачі, але перед наступною. Використовуйте це для асинхронних перетворень.
| `asyncScheduler` | Розклади працюють із `setInterval`. Використовуйте це для операцій на основі часу.
| `animationFrameScheduler` | Планує завдання, яке відбудеться перед наступним перефарбуванням вмісту браузера. Можна використовувати для створення плавної анімації браузера.

## Використання планувальників

Можливо, ви вже використовували планувальники у своєму коді RxJS без явного вказівки типу планувальників, які слід використовувати. Це пояснюється тим, що всі оператори Об'єкту Спостереження, які мають справу з асинхронністю, мають додаткові планувальники. 

Якщо ви не надасте планувальник, RxJS вибере планувальник за замовчуванням за принципом найменшої асинхронності. Це означає, що вибирається планувальник, який вводить найменшу кількість паралельності, що задовольняє потреби оператора. 

Наприклад, для операторів, які повертають Об'єкт Спостереження з кінечною та невеликою кількістю повідомлень, RxJS не використовує планувальника, тобто нульовий або невизначений. Для операторів, які повертають потенційно велику або нескінченну кількість повідомлень, використовується планувальник черги. Для операторів, які використовують таймери, використовується `async`.

Оскільки RxJS використовує планувальник з найменшим паралелізмом, ви можете вибрати інший планувальник, якщо хочете запровадити паралелізм для підвищення продуктивності. Щоб вказати конкретний планувальник, ви можете використовувати ті методи операторів, які беруть планувальник, наприклад, `from([10, 20, 30], asyncScheduler)`.

Статичні оператори створення зазвичай приймають планувальник як аргумент. Наприклад, `from(array, scheduler)` дозволяє вказати планувальник, який використовуватиметься під час доставки кожного сповіщення, перетвореного з масиву. Зазвичай це останній аргумент для оператора. Наступні статичні оператори створення приймають аргумент планувальника:

`bindCallback`
`bindNodeCallback`
`combineLatest`
`concat`
`empty`
`from`
`fromPromise`
`interval`
`merge`
`of`
`range`
`throw`
`timer`

Використовуйте `subscribeOn`, щоб запланувати, у якому контексті відбуватиметься виклик `subscribe()`. За замовчуванням виклик `subscribe()` для Об'єкта Спостереження відбуватиметься синхронно та негайно. Однак ви можете відкласти або запланувати фактичну підписку на певний планувальник, використовуючи оператор екземпляра `subscribeOn(scheduler)`, де планувальник — це наданий вами аргумент.

Використовуйте `observeOn`, щоб запланувати, у якому контексті надсилатимуться сповіщення. Як ми бачили в наведених вище прикладах, оператор екземпляра `observeOn(scheduler)` вводить посередника-спостерігача між вихідним Об'єктом Спостереження і цільовим Спостерігачем, де посередник планує виклики цільового Спостерігача за допомогою заданого планувальника.

Оператори екземплярів можуть приймати Планувальник як аргумент.

Оператори, пов’язані з часом, як-от `bufferTime`, `debounceTime`, `delay`, `auditTime`, `sampleTime`, `throttleTime`, `timeInterval`, `timeout`, `timeoutWith`, `windowTime`, приймають планувальник як останній аргумент, а в інших випадках діють за умовчанням на `asyncScheduler`.

Інші оператори екземплярів, які приймають планувальник як аргумент: `cache`, `combineLatest`, `concat`, `expand`, `merge`, `publishReplay`, `startWith`.

Зауважте, що і `cache`, і `publishReplay` приймають планувальник, оскільки вони використовують ReplaySubject. Конструктор ReplaySubjects приймає необов’язковий Scheduler як останній аргумент, оскільки ReplaySubject може мати справу з часом, що має сенс лише в контексті Scheduler. За замовчуванням ReplaySubject використовує планувальник черги, щоб надати годинник.